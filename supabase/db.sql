-- -----------------------------------------------------------------------------
-- Extensions (Ensure these are enabled in your Supabase project if not already)
-- -----------------------------------------------------------------------------
-- CREATE EXTENSION IF NOT EXISTS moddatetime; -- For updated_at trigger

-- -----------------------------------------------------------------------------
-- Enum Types
-- -----------------------------------------------------------------------------
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'scan_status') THEN
        CREATE TYPE public.scan_status AS ENUM (
            'accepted',
            'rejected',
            'doubtful'
        );
    END IF;
END$$;

-- -----------------------------------------------------------------------------
-- Tables
-- -----------------------------------------------------------------------------

-- Students Table
CREATE TABLE IF NOT EXISTS public.students (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  tag_uid TEXT UNIQUE NOT NULL,
  full_name TEXT NOT NULL,
  class_name TEXT NOT NULL,
  face_image_path TEXT NULL, -- Path to primary face image in Storage
  created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT now() NOT NULL
);

-- Sessions Table
CREATE TABLE IF NOT EXISTS public.sessions (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL,
  class_name TEXT NOT NULL,
  started_at TIMESTAMPTZ NOT NULL,
  ended_at TIMESTAMPTZ NULL,
  created_at TIMESTAMPTZ DEFAULT now() NOT NULL, -- Added for consistency
  updated_at TIMESTAMPTZ DEFAULT now() NOT NULL  -- Added for consistency
);

-- Attendance Logs Table
CREATE TABLE IF NOT EXISTS public.attendance_logs (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  tag_uid TEXT NOT NULL,
  session_id BIGINT NOT NULL CONSTRAINT fk_session REFERENCES public.sessions(id) ON DELETE RESTRICT,
  scanned_at TIMESTAMPTZ DEFAULT now() NOT NULL,
  reader_id TEXT NULL,
  scan_face_image_path TEXT NULL, -- Path to face image captured at scan
  status public.scan_status DEFAULT 'accepted' NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now() NOT NULL, -- Added for consistency
  updated_at TIMESTAMPTZ DEFAULT now() NOT NULL  -- Added for consistency (e.g., when status changes)
);


-- -----------------------------------------------------------------------------
-- Indexes
-- -----------------------------------------------------------------------------

-- Students Indexes
CREATE INDEX IF NOT EXISTS idx_students_tag_uid ON public.students(tag_uid);
CREATE INDEX IF NOT EXISTS idx_students_class_name ON public.students(class_name);

-- Sessions Indexes
CREATE INDEX IF NOT EXISTS idx_sessions_class_name ON public.sessions(class_name);
CREATE INDEX IF NOT EXISTS idx_sessions_started_at ON public.sessions(started_at DESC);
CREATE INDEX IF NOT EXISTS idx_sessions_ended_at ON public.sessions(ended_at);

-- Attendance Logs Indexes
CREATE INDEX IF NOT EXISTS idx_attendance_logs_tag_uid ON public.attendance_logs(tag_uid);
CREATE INDEX IF NOT EXISTS idx_attendance_logs_session_id ON public.attendance_logs(session_id);
CREATE INDEX IF NOT EXISTS idx_attendance_logs_scanned_at ON public.attendance_logs(scanned_at);
CREATE INDEX IF NOT EXISTS idx_attendance_logs_status ON public.attendance_logs(status);
CREATE INDEX IF NOT EXISTS idx_attendance_logs_tag_session_scan ON public.attendance_logs(tag_uid, session_id, scanned_at DESC);


-- -----------------------------------------------------------------------------
-- Triggers for updated_at
-- -----------------------------------------------------------------------------

-- General function to update the updated_at column
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger for students table
DROP TRIGGER IF EXISTS on_students_update ON public.students; -- Drop if exists to avoid conflict
CREATE TRIGGER on_students_update
  BEFORE UPDATE ON public.students
  FOR EACH ROW
  EXECUTE PROCEDURE public.handle_updated_at();

-- Trigger for sessions table
DROP TRIGGER IF EXISTS on_sessions_update ON public.sessions;
CREATE TRIGGER on_sessions_update
  BEFORE UPDATE ON public.sessions
  FOR EACH ROW
  EXECUTE PROCEDURE public.handle_updated_at();

-- Trigger for attendance_logs table (status changes update this)
DROP TRIGGER IF EXISTS on_attendance_logs_update ON public.attendance_logs;
CREATE TRIGGER on_attendance_logs_update
  BEFORE UPDATE ON public.attendance_logs
  FOR EACH ROW
  EXECUTE PROCEDURE public.handle_updated_at();


-- -----------------------------------------------------------------------------
-- Row Level Security (RLS) - Basic Setup
-- -----------------------------------------------------------------------------
-- Enable RLS for each table
ALTER TABLE public.students ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.attendance_logs ENABLE ROW LEVEL SECURITY;

-- Allow authenticated users to perform all actions.
-- WARNING: This is very permissive. Refine these for production!
DROP POLICY IF EXISTS "Authenticated users can manage all students" ON public.students;
CREATE POLICY "Authenticated users can manage all students"
  ON public.students
  to authenticated
  USING (true)
  WITH CHECK (true);

DROP POLICY IF EXISTS "Authenticated users can manage all sessions" ON public.sessions;
CREATE POLICY "Authenticated users can manage all sessions"
  ON public.sessions
  to anon, authenticated
  USING (true)
  WITH CHECK (true);

DROP POLICY IF EXISTS "Authenticated users can manage all attendance_logs" ON public.attendance_logs;
CREATE POLICY "Authenticated users can manage all attendance_logs"
  ON public.attendance_logs
  to anon, authenticated
  USING (true)
  WITH CHECK (true);

-- Allow service_role (e.g., for Raspberry Pi inserts) to bypass RLS for attendance_logs
-- Supabase service_role key bypasses RLS by default, so this might not be strictly
-- necessary if the Pi uses that key. However, explicitly defining can be clearer
-- if you ever change how the Pi authenticates or want to use a specific role.
-- This is more for illustration if you set up a dedicated role for the device.
-- For now, relying on service_role default bypass is fine.


-- -----------------------------------------------------------------------------
-- Functions
-- -----------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION public.start_session(
    p_name TEXT,
    p_class_name TEXT
)
RETURNS BIGINT
LANGUAGE plpgsql
SECURITY DEFINER -- Runs with privileges of the function owner
AS $$
DECLARE
  v_new_session_id BIGINT;
BEGIN
  -- Ensure user is authenticated if called directly (though app UI should handle this)
  -- IF auth.uid() IS NULL THEN RAISE EXCEPTION 'User must be authenticated to start a session'; END IF;

  INSERT INTO public.sessions (name, class_name, started_at, ended_at)
  VALUES (p_name, p_class_name, now(), NULL)
  RETURNING id INTO v_new_session_id;

  RETURN v_new_session_id;
END;
$$;


CREATE OR REPLACE FUNCTION public.end_latest_session()
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_active_session_id BIGINT;
BEGIN
  SELECT id INTO v_active_session_id
  FROM public.sessions
  WHERE ended_at IS NULL
  ORDER BY started_at DESC
  LIMIT 1;

  IF NOT FOUND THEN
    RAISE WARNING 'end_latest_session: No active session found to end.';
    RETURN FALSE;
  END IF;

  UPDATE public.sessions
  SET ended_at = now()
  WHERE id = v_active_session_id;

  RETURN TRUE;
END;
$$;


CREATE OR REPLACE FUNCTION public.scan_attendance(
    p_tag_uid TEXT,
    p_reader_id TEXT DEFAULT NULL,
    p_scan_face_image_path TEXT DEFAULT NULL -- Added for future face capture
)
RETURNS BOOLEAN
LANGUAGE plpgsql
-- SECURITY INVOKER is safer if called by trusted backend (like RPi with service key)
-- SECURITY DEFINER if RLS needs to be bypassed by this function for specific inserts
-- Given it's for RPi, SECURITY INVOKER with a service_role key is common.
-- If using a less privileged role for RPi, SECURITY DEFINER + RLS for that role to insert might be needed.
-- For simplicity with service_role, INVOKER is fine.
SECURITY INVOKER -- Assuming RPi uses service_role key which bypasses RLS
AS $$
DECLARE
  v_active_session_id BIGINT;
  v_debounce_interval INTERVAL := interval '1 minute'; -- Reduced debounce for testing, adjust as needed
  v_last_scan_time TIMESTAMPTZ;
BEGIN
  SELECT id INTO v_active_session_id
  FROM public.sessions
  WHERE ended_at IS NULL
  ORDER BY started_at DESC
  LIMIT 1;

  IF NOT FOUND THEN
    RAISE WARNING 'Scan rejected (scan_attendance): No active session for tag_uid %.', p_tag_uid;
    RETURN FALSE;
  END IF;

  -- Debounce Check: Check last scan for this tag in this session
  SELECT scanned_at INTO v_last_scan_time
  FROM public.attendance_logs
  WHERE tag_uid = p_tag_uid
    AND session_id = v_active_session_id
  ORDER BY scanned_at DESC
  LIMIT 1;

  IF v_last_scan_time IS NOT NULL AND v_last_scan_time > (now() - v_debounce_interval) THEN
    RAISE NOTICE 'Scan debounced (scan_attendance): Tag UID % recently scanned for session %.', p_tag_uid, v_active_session_id;
    RETURN TRUE; -- Acknowledge scan, but don't log again
  END IF;

  INSERT INTO public.attendance_logs (tag_uid, session_id, reader_id, scanned_at, scan_face_image_path, status)
  VALUES (p_tag_uid, v_active_session_id, p_reader_id, now(), p_scan_face_image_path, 'accepted'); -- Default status

  RETURN TRUE;
EXCEPTION
  WHEN OTHERS THEN
    RAISE WARNING 'Error in scan_attendance for tag %: %', p_tag_uid, SQLERRM;
    RETURN FALSE;
END;
$$;


CREATE OR REPLACE FUNCTION public.update_scan_status(
    p_log_id BIGINT,
    p_new_status public.scan_status
    -- p_rejection_reason TEXT DEFAULT NULL -- Uncomment if you add rejection_reason column
)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER -- Requires careful RLS or in-function checks if not admin only
AS $$
BEGIN
  -- Example: Ensure only specific roles or conditions allow status update
  -- IF NOT (auth.role() = 'service_role' OR (SELECT is_admin FROM public.user_profiles WHERE id = auth.uid())) THEN
  --   RAISE EXCEPTION 'Permission denied to update scan status.';
  -- END IF;

  UPDATE public.attendance_logs
  SET status = p_new_status
      -- ,rejection_reason = CASE WHEN p_new_status = 'rejected' THEN p_rejection_reason ELSE NULL END -- If column exists
  WHERE id = p_log_id;

  IF NOT FOUND THEN
    RAISE WARNING 'Log ID % not found for status update.', p_log_id;
    RETURN FALSE;
  END IF;
  RETURN TRUE;
EXCEPTION
  WHEN OTHERS THEN
    RAISE WARNING 'Error updating scan status for log %: %', p_log_id, SQLERRM;
    RETURN FALSE;
END;
$$;
-- Update comment if rejection_reason is added: COMMENT ON FUNCTION public.update_scan_status(BIGINT, public.scan_status, TEXT) ...


CREATE OR REPLACE FUNCTION public.get_attendance_logs_with_details(
    p_session_id_filter BIGINT DEFAULT NULL,
    p_class_name_filter TEXT DEFAULT NULL,
    p_scan_status_filter public.scan_status DEFAULT NULL -- New filter
)
RETURNS TABLE (
    log_id BIGINT,
    scan_time TIMESTAMPTZ,
    tag_uid TEXT,
    student_name TEXT,
    student_class_name TEXT,
    student_face_image_path TEXT,
    session_id BIGINT,
    session_name TEXT,
    session_class_name TEXT,
    reader_id TEXT,
    scan_status public.scan_status,
    scan_face_image_path TEXT
)
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  SELECT
    al.id as log_id,
    al.scanned_at as scan_time,
    al.tag_uid,
    s.full_name as student_name,
    s.class_name as student_class_name,
    s.face_image_path as student_face_image_path,
    al.session_id,
    sess.name as session_name,
    sess.class_name as session_class_name,
    al.reader_id,
    al.status as scan_status,
    al.scan_face_image_path
  FROM
    public.attendance_logs al
    LEFT JOIN public.students s ON al.tag_uid = s.tag_uid
    LEFT JOIN public.sessions sess ON al.session_id = sess.id
  WHERE
    (p_session_id_filter IS NULL OR al.session_id = p_session_id_filter)
    AND
    (p_class_name_filter IS NULL OR sess.class_name = p_class_name_filter)
    AND
    (p_scan_status_filter IS NULL OR al.status = p_scan_status_filter) -- Apply status filter
  ORDER BY
    al.scanned_at DESC;
END;
$$;


CREATE OR REPLACE FUNCTION public.get_session_attendance_report(
    p_session_id_param BIGINT
)
RETURNS TABLE (
    student_id BIGINT,
    student_full_name TEXT,
    student_tag_uid TEXT,
    student_class_name TEXT,
    student_face_image_path TEXT,
    session_id BIGINT,
    session_name TEXT,
    session_class_name TEXT,
    attendance_status TEXT,
    first_scanned_at TIMESTAMPTZ
)
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
AS $$
DECLARE
    v_session_record RECORD;
BEGIN
    SELECT s.id, s.name, s.class_name
    INTO v_session_record
    FROM public.sessions s
    WHERE s.id = p_session_id_param;

    IF NOT FOUND THEN
        RAISE WARNING 'Session ID % not found for report.', p_session_id_param;
        RETURN;
    END IF;

    RETURN QUERY
    SELECT
        st.id AS student_id,
        st.full_name AS student_full_name,
        st.tag_uid AS student_tag_uid,
        st.class_name AS student_class_name,
        st.face_image_path as student_face_image_path,
        v_session_record.id AS session_id,
        v_session_record.name AS session_name,
        v_session_record.class_name AS session_class_name,
        CASE
            WHEN al_agg.log_count > 0 THEN 'Present'
            ELSE 'Absent'
        END AS attendance_status,
        al_agg.min_scanned_at AS first_scanned_at
    FROM
        public.students st
    LEFT JOIN (
        SELECT
            al_inner.tag_uid,
            MIN(al_inner.scanned_at) AS min_scanned_at,
            COUNT(al_inner.id) AS log_count -- Count non-rejected logs
        FROM
            public.attendance_logs al_inner
        WHERE
            al_inner.session_id = p_session_id_param
            AND al_inner.status <> 'rejected' -- Exclude rejected scans
        GROUP BY
            al_inner.tag_uid
    ) al_agg ON st.tag_uid = al_agg.tag_uid
    WHERE
        st.class_name = v_session_record.class_name -- Students registered for the session's class
    ORDER BY
        st.full_name;
END;
$$;


CREATE OR REPLACE FUNCTION public.get_student_attendance_summary(
    p_student_id_param BIGINT
)
RETURNS TABLE (
    student_id BIGINT,
    student_full_name TEXT,
    student_tag_uid TEXT,
    student_class_name TEXT,
    student_face_image_path TEXT,
    total_relevant_sessions BIGINT,
    sessions_attended BIGINT,
    attendance_percentage NUMERIC,
    session_id BIGINT,
    session_name TEXT,
    session_started_at TIMESTAMPTZ,
    session_ended_at TIMESTAMPTZ,
    student_status_for_session TEXT,
    first_scanned_at_for_session TIMESTAMPTZ
)
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
AS $$
DECLARE
    v_student_record RECORD;
BEGIN
    SELECT s.id, s.full_name, s.tag_uid, s.class_name, s.face_image_path
    INTO v_student_record
    FROM public.students s
    WHERE s.id = p_student_id_param;

    IF NOT FOUND THEN
        RAISE WARNING 'Student ID % not found for summary.', p_student_id_param;
        RETURN;
    END IF;

    RETURN QUERY
    WITH relevant_student_sessions AS (
        SELECT
            sess.id AS session_id,
            sess.name AS session_name,
            sess.started_at AS session_started_at,
            sess.ended_at AS session_ended_at
        FROM public.sessions sess
        WHERE sess.class_name = v_student_record.class_name -- Sessions for the student's class
    ),
    student_attendance_details AS (
        SELECT
            rs.session_id,
            rs.session_name,
            rs.session_started_at,
            rs.session_ended_at,
            EXISTS (
                SELECT 1
                FROM public.attendance_logs al
                WHERE al.tag_uid = v_student_record.tag_uid
                  AND al.session_id = rs.session_id
                  AND al.status <> 'rejected' -- Exclude rejected scans
            ) AS attended_session,
            (
                SELECT MIN(al_min.scanned_at)
                FROM public.attendance_logs al_min
                WHERE al_min.tag_uid = v_student_record.tag_uid
                  AND al_min.session_id = rs.session_id
                  AND al_min.status <> 'rejected' -- Exclude rejected scans
            ) AS first_scan_time
        FROM relevant_student_sessions rs
    ),
    overall_student_stats AS (
        SELECT
            COUNT(*) AS total_class_sessions,
            SUM(CASE WHEN sad.attended_session THEN 1 ELSE 0 END) AS total_sessions_attended_by_student
        FROM student_attendance_details sad
    )
    SELECT
        v_student_record.id,
        v_student_record.full_name,
        v_student_record.tag_uid,
        v_student_record.class_name,
        v_student_record.face_image_path,
        COALESCE(oss.total_class_sessions, 0),
        COALESCE(oss.total_sessions_attended_by_student, 0),
        CASE
            WHEN COALESCE(oss.total_class_sessions, 0) > 0 THEN
                TRUNC((COALESCE(oss.total_sessions_attended_by_student, 0)::NUMERIC * 100.0 / oss.total_class_sessions), 2)
            ELSE 0.00
        END,
        sad.session_id,
        sad.session_name,
        sad.session_started_at,
        sad.session_ended_at,
        CASE WHEN sad.attended_session THEN 'Present'::TEXT ELSE 'Absent'::TEXT END,
        sad.first_scan_time
    FROM
        student_attendance_details sad,
        overall_student_stats oss -- Cross join to make stats available for each session row
    ORDER BY
        sad.session_started_at DESC;
END;
$$;


CREATE OR REPLACE FUNCTION public.get_students_with_summary_stats(
    p_name_filter TEXT DEFAULT NULL,
    p_class_filter TEXT DEFAULT NULL
)
RETURNS TABLE (
    id BIGINT,
    tag_uid TEXT,
    full_name TEXT,
    class_name TEXT,
    face_image_path TEXT,
    created_at TIMESTAMPTZ,
    updated_at TIMESTAMPTZ,
    total_relevant_sessions BIGINT,
    sessions_attended BIGINT
)
LANGUAGE plpgsql
STABLE
SECURITY DEFINER -- Or INVOKER, depending on your RLS strategy for accessing students and logs
AS $$
BEGIN
    RETURN QUERY
    SELECT
        s.id,
        s.tag_uid,
        s.full_name,
        s.class_name,
        s.face_image_path,
        s.created_at,
        s.updated_at,
        COALESCE(stats.total_relevant_sessions, 0) AS total_relevant_sessions,
        COALESCE(stats.sessions_attended, 0) AS sessions_attended
    FROM
        public.students s
    LEFT JOIN LATERAL (
        -- Calculate stats for each student
        SELECT
            COUNT(DISTINCT sess.id) AS total_relevant_sessions,
            COUNT(DISTINCT CASE WHEN al.id IS NOT NULL THEN sess.id ELSE NULL END) AS sessions_attended
        FROM
            public.sessions sess
        LEFT JOIN public.attendance_logs al
            ON al.session_id = sess.id
            AND al.tag_uid = s.tag_uid -- Match student's tag
            AND al.status <> 'rejected' -- Only count non-rejected scans for attendance
        WHERE
            sess.class_name = s.class_name -- Sessions relevant to this student's class
    ) stats ON TRUE
    WHERE
        (p_name_filter IS NULL OR s.full_name ILIKE '%' || p_name_filter || '%') -- Case-insensitive name filter
        AND
        (p_class_filter IS NULL OR s.class_name = p_class_filter) -- Exact class filter
    ORDER BY
        s.full_name ASC;
END;
$$;

-- -----------------------------------------------------------------------------
-- End of Script
-- -----------------------------------------------------------------------------